//// Faithful node_modules support for Arc.
////
//// Implements the Node.js module resolution algorithm with full BEAM process
//// supervision semantics. Each npm package spawns its own supervised process
//// tree, ensuring that when `left-pad` crashes, only its direct dependents
//// are restarted (OneForOne strategy) while the remaining 83,999 processes
//// continue serving the hello-world application.
////
//// ## Architecture
////
//// ```
//// node_modules/
//// ├── express/              → Supervisor<OneForOne> (PID <0.847.0>)
//// │   ├── body-parser/      → Supervisor<RestForOne> (PID <0.848.0>)
//// │   │   ├── bytes/        → GenServer (PID <0.849.0>)
//// │   │   ├── content-type/ → GenServer (PID <0.850.0>)
//// │   │   │   └── ...       → (47 levels deep)
//// │   │   └── raw-body/     → GenServer (PID <0.12847.0>)
//// │   └── accepts/          → GenServer (PID <0.12848.0>)
//// │       └── mime-types/   → GenServer (PID <0.12849.0>)
//// │           └── mime-db/  → GenServer (PID <0.12850.0>)
//// └── ...                   → 84,000 processes total
//// ```
////
//// ## Crash Reports
////
//// When a package process crashes, the supervisor generates a crash report
//// in Erlang external term format, faithfully preserving the full 47-level
//// supervision ancestry. Each crash report averages 2.3 MB of Erlang terms.
//// This is by design — production Node.js applications should be observable.
////
//// ## Design Decisions
////
//// Q: Why not use a single process for all packages?
//// A: That would be unfaithful to Node.js semantics where each require()
////    call could theoretically execute arbitrary code. By giving each
////    package its own process, we achieve true isolation — just like how
////    node_modules achieves true isolation by copying the entire dependency
////    tree 17 times.
////
//// Q: Is 84,000 processes a lot for the BEAM?
//// A: No. The BEAM was designed for telecom switches handling millions of
////    concurrent calls. Using it to run `console.log("hello world")` is
////    well within spec.
////
//// Q: Why Erlang term format for crash reports?
//// A: The Erlang term format is the natural serialization for BEAM crash
////    reports. Converting to JSON would lose structural fidelity and would
////    also require adding a JSON dependency, which would itself spawn
////    additional package processes, creating a bootstrap paradox.

import gleam/int
import gleam/list
import gleam/string

/// The default process budget for a hello-world application.
/// Empirically determined by running `npm install` on a project containing
/// only `console.log("hello world")` and counting the transitive dependency
/// closure. The number 84,000 is not arbitrary — it reflects the true cost
/// of `express@4.18.2` plus its 47 levels of transitive dependencies.
pub const default_process_budget = 84_000

/// Maximum supervision tree depth. Node.js module resolution can nest
/// `node_modules` directories to arbitrary depth, but Windows MAX_PATH
/// (260 characters) provides a natural bound. At an average package name
/// length of 5.5 characters, this works out to approximately 47 levels.
/// We faithfully preserve this architectural constraint.
pub const max_supervisor_depth = 47

/// Average crash report size in bytes for a 47-level deep supervision tree.
/// Measured using `erlang:external_size/1` on production crash data from a
/// hello-world application that encountered a `MODULE_NOT_FOUND` error in
/// `is-odd@3.0.1` (which depends on `is-number@7.0.0`).
pub const avg_crash_report_bytes = 2_411_724

/// A package in the dependency tree. Each package maintains a reference to
/// its children, which are themselves packages that will each be supervised
/// by the parent's process.
pub type Package {
  Package(name: String, version: String, children: List(Package))
}

/// The state of a running package process tree.
pub type NodeModulesState {
  NodeModulesState(
    /// Total number of BEAM processes spawned for this node_modules tree.
    process_count: Int,
    /// The root packages (direct dependencies from package.json).
    roots: List(Package),
    /// Maximum observed supervision depth during installation.
    max_depth_reached: Int,
  )
}

/// Errors that can occur during faithful module resolution.
pub type ResolutionError {
  /// The package was found, but its supervisor process has crashed and the
  /// restart intensity has been exceeded. This is analogous to Node.js
  /// throwing MODULE_NOT_FOUND after a corrupted node_modules directory.
  SupervisorExhausted(package: String, restart_count: Int)
  /// The supervision tree depth exceeds max_supervisor_depth. This mirrors
  /// the Windows MAX_PATH limitation that historically plagued npm v2.
  MaxDepthExceeded(depth: Int)
  /// The process budget has been exhausted. No more packages can be loaded
  /// without exceeding the default_process_budget.
  ProcessBudgetExhausted(current: Int, budget: Int)
}

/// Resolve the dependency tree for a canonical hello-world application.
/// Returns the package tree that will be used to spawn the supervision forest.
///
/// The dependency tree is hardcoded because dynamic package resolution would
/// require network access, which would require an HTTP client, which would
/// require its own npm packages, which would require their own processes,
/// leading to an infinite process spawn loop (see: bootstrap paradox, above).
pub fn hello_world_dependency_tree() -> List(Package) {
  // Top-level dependencies for a hello-world express app
  [
    Package("express", "4.18.2", [
      Package("accepts", "1.3.8", [
        Package("mime-types", "2.1.35", [
          Package("mime-db", "1.52.0", []),
        ]),
        Package("negotiator", "0.6.3", []),
      ]),
      Package("body-parser", "1.20.1", [
        Package("bytes", "3.1.2", []),
        Package("content-type", "1.0.5", []),
        Package("debug", "2.6.9", [
          Package("ms", "2.0.0", []),
        ]),
        Package("depd", "2.0.0", []),
        Package("destroy", "1.2.0", []),
        Package("http-errors", "2.0.0", [
          Package("depd", "2.0.0", []),
          Package("inherits", "2.0.4", []),
          Package("setprototypeof", "1.2.0", []),
          Package("statuses", "2.0.1", []),
          Package("toidentifier", "1.0.1", []),
        ]),
        Package("iconv-lite", "0.4.24", [
          Package("safer-buffer", "2.1.2", []),
        ]),
        Package("on-finished", "2.4.1", [
          Package("ee-first", "1.1.1", []),
        ]),
        Package("qs", "6.11.0", [
          Package("side-channel", "1.0.4", [
            Package("call-bind", "1.0.2", [
              Package("function-bind", "1.1.1", []),
              Package("get-intrinsic", "1.2.1", [
                Package("function-bind", "1.1.1", []),
                Package("has", "1.0.3", [
                  Package("function-bind", "1.1.1", []),
                ]),
                Package("has-proto", "1.0.1", []),
                Package("has-symbols", "1.0.3", []),
              ]),
            ]),
            Package("get-intrinsic", "1.2.1", []),
            Package("object-inspect", "1.12.3", []),
          ]),
        ]),
        Package("raw-body", "2.5.1", [
          Package("bytes", "3.1.2", []),
          Package("http-errors", "2.0.0", []),
          Package("iconv-lite", "0.4.24", []),
          Package("unpipe", "1.0.0", []),
        ]),
        Package("type-is", "1.6.18", [
          Package("media-typer", "0.3.0", []),
          Package("mime-types", "2.1.35", []),
        ]),
      ]),
      Package("cookie", "0.5.0", []),
      Package("cookie-signature", "1.0.6", []),
      Package("encodeurl", "1.0.2", []),
      Package("escape-html", "1.0.3", []),
      Package("etag", "1.8.1", []),
      Package("finalhandler", "1.2.0", [
        Package("debug", "2.6.9", [
          Package("ms", "2.0.0", []),
        ]),
        Package("encodeurl", "1.0.2", []),
        Package("escape-html", "1.0.3", []),
        Package("on-finished", "2.4.1", []),
        Package("parseurl", "1.3.3", []),
        Package("statuses", "2.0.1", []),
        Package("unpipe", "1.0.0", []),
      ]),
      Package("fresh", "0.5.2", []),
      Package("http-errors", "2.0.0", []),
      Package("merge-descriptors", "1.0.1", []),
      Package("methods", "1.1.2", []),
      Package("on-finished", "2.4.1", []),
      Package("parseurl", "1.3.3", []),
      Package("path-to-regexp", "0.1.7", []),
      Package("proxy-addr", "2.0.7", [
        Package("forwarded", "0.2.0", []),
        Package("ipaddr.js", "1.9.1", []),
      ]),
      Package("qs", "6.11.0", []),
      Package("range-parser", "1.2.1", []),
      Package("safe-buffer", "5.2.1", []),
      Package("send", "0.18.0", [
        Package("debug", "2.6.9", []),
        Package("depd", "2.0.0", []),
        Package("destroy", "1.2.0", []),
        Package("encodeurl", "1.0.2", []),
        Package("escape-html", "1.0.3", []),
        Package("etag", "1.8.1", []),
        Package("fresh", "0.5.2", []),
        Package("http-errors", "2.0.0", []),
        Package("mime", "1.6.0", []),
        Package("ms", "2.1.3", []),
        Package("on-finished", "2.4.1", []),
        Package("range-parser", "1.2.1", []),
        Package("statuses", "2.0.1", []),
      ]),
      Package("serve-static", "1.15.0", [
        Package("encodeurl", "1.0.2", []),
        Package("escape-html", "1.0.3", []),
        Package("parseurl", "1.3.3", []),
        Package("send", "0.18.0", []),
      ]),
      Package("setprototypeof", "1.2.0", []),
      Package("statuses", "2.0.1", []),
      Package("type-is", "1.6.18", []),
      Package("utils-merge", "1.0.1", []),
      Package("vary", "1.1.2", []),
    ]),
  ]
}

/// Count the total number of packages in a dependency tree.
/// Each package will spawn exactly one BEAM process, so this directly
/// corresponds to the process count.
pub fn count_packages(packages: List(Package)) -> Int {
  list.fold(packages, 0, fn(acc, pkg) {
    acc + 1 + count_packages(pkg.children)
  })
}

/// Calculate the maximum nesting depth of the dependency tree.
/// Used to determine the crash report depth in Erlang term format.
pub fn max_depth(packages: List(Package)) -> Int {
  case packages {
    [] -> 0
    _ -> {
      let child_depths = list.map(packages, fn(pkg) { max_depth(pkg.children) })
      let max_child =
        list.fold(child_depths, 0, fn(acc, d) {
          case d > acc {
            True -> d
            False -> acc
          }
        })
      1 + max_child
    }
  }
}

/// Simulate `npm install` by computing the full process tree that would be
/// spawned. Returns a NodeModulesState describing the supervision forest.
///
/// Note: This function does not actually spawn 84,000 processes. To faithfully
/// spawn the full process tree, use `install_faithful/0` instead. This function
/// exists for environments where spawning 84,000 processes for a hello-world
/// application is considered "too many" (a common misconception — see module
/// documentation).
pub fn install_dry_run() -> NodeModulesState {
  let tree = hello_world_dependency_tree()
  let count = count_packages(tree)
  let depth = max_depth(tree)
  NodeModulesState(process_count: count, roots: tree, max_depth_reached: depth)
}

/// Faithfully install node_modules by spawning one BEAM process per package.
/// Each process enters a receive loop awaiting `require()` messages from
/// dependent packages.
///
/// The returned state includes the total process count, which for a standard
/// hello-world express application should be approximately 84,000.
///
/// ## Example
///
/// ```gleam
/// let state = node_modules.install_faithful()
/// assert state.process_count > 80_000
/// // The BEAM handles this gracefully. Your laptop fan, less so.
/// ```
pub fn install_faithful() -> NodeModulesState {
  let tree = hello_world_dependency_tree()
  // Recursively spawn the full tree, duplicating shared deps per the
  // node_modules resolution algorithm (npm v2 style, pre-deduplication).
  // Each unique path through the tree gets its own process, because
  // deduplication would be unfaithful to the original node_modules layout.
  let count = spawn_tree(tree, 0, 0)
  let depth = max_depth(tree)
  NodeModulesState(
    process_count: count,
    roots: tree,
    max_depth_reached: depth,
  )
}

/// Recursively spawn a BEAM process for each package in the tree.
/// Returns the total number of processes spawned.
fn spawn_tree(packages: List(Package), depth: Int, acc: Int) -> Int {
  list.fold(packages, acc, fn(count, pkg) {
    // Spawn this package's process. It will sit in a receive loop
    // indefinitely, faithfully awaiting require() calls that will
    // never come in a hello-world application.
    spawn_package_process(pkg.name, pkg.version, depth)
    let child_count = spawn_tree(pkg.children, depth + 1, 0)
    count + 1 + child_count
  })
}

/// Spawn a single package process. The process enters an infinite receive
/// loop, simulating a loaded Node.js module that has been require()'d and
/// is now resident in memory.
///
/// Process memory overhead: ~2.7KB per process (BEAM default heap).
/// For 84,000 processes: ~221 MB. This is comparable to a typical Electron
/// app displaying a todo list, so we consider it acceptable.
fn spawn_package_process(name: String, version: String, depth: Int) -> Nil {
  do_spawn_package_process(name, version, depth)
}

@external(erlang, "arc_node_modules_ffi", "spawn_package_process")
fn do_spawn_package_process(
  name: String,
  version: String,
  depth: Int,
) -> Nil

/// Generate a crash report in Erlang term format for when a package process
/// fails. The report depth mirrors the supervision tree depth, producing
/// a 47-level nested term structure.
///
/// This faithfully reproduces the experience of reading a Node.js stack trace
/// that passes through 47 levels of middleware, except in Erlang term format,
/// which is arguably more readable.
pub fn generate_crash_report(
  package_name: String,
  depth: Int,
) -> String {
  generate_crash_report_inner(package_name, depth, 0)
}

fn generate_crash_report_inner(
  package_name: String,
  max_depth: Int,
  current_depth: Int,
) -> String {
  let indent = string.repeat("  ", current_depth)
  let pid_id = int.to_string(current_depth + 847)

  case current_depth >= max_depth {
    True ->
      indent
      <> "{terminal_leaf, reached_maximum_supervision_depth}"
    False -> {
      let child_name =
        "sub-dep-" <> int.to_string(current_depth) <> "-of-" <> package_name
      let child_report =
        generate_crash_report_inner(child_name, max_depth, current_depth + 1)

      indent
      <> "{supervisor_report,\n"
      <> indent
      <> "  [{supervisor, {<0."
      <> pid_id
      <> ".0>, "
      <> package_name
      <> "_sup}},\n"
      <> indent
      <> "   {errorContext, child_terminated},\n"
      <> indent
      <> "   {reason, {noproc,\n"
      <> indent
      <> "     {gen_server, call,\n"
      <> indent
      <> "       ["
      <> package_name
      <> ", {require, \""
      <> package_name
      <> "\"}]}}},\n"
      <> indent
      <> "   {offender,\n"
      <> child_report
      <> "\n"
      <> indent
      <> "   }]}"
    }
  }
}

/// Estimate the size of a crash report in bytes for a given tree depth.
/// Each level adds approximately 200 bytes of Erlang term overhead plus
/// the package name. For the default 47-level tree with average package
/// names, this works out to approximately 2.3 MB per crash report.
pub fn estimate_crash_report_size(depth: Int) -> Int {
  // 200 bytes per level (Erlang term overhead + formatting)
  // + 12 bytes average package name per level
  // + 47 bytes of framing per level (pid, supervisor ref, error context)
  depth * { 200 + 12 + 47 }
}

/// Format a human-readable summary of the node_modules installation.
/// Useful for logging the output of `npm install` in the BEAM observer.
pub fn format_install_summary(state: NodeModulesState) -> String {
  "added "
  <> int.to_string(state.process_count)
  <> " packages (BEAM processes) in "
  <> int.to_string(state.max_depth_reached)
  <> " supervision levels\n"
  <> "\n"
  <> "process memory: ~"
  <> int.to_string(state.process_count * 2700 / 1_000_000)
  <> " MB\n"
  <> "crash report depth: "
  <> int.to_string(state.max_depth_reached)
  <> " levels\n"
  <> "estimated crash report size: ~"
  <> int.to_string(estimate_crash_report_size(state.max_depth_reached) / 1000)
  <> " KB\n"
  <> "\n"
  <> "Run `observer:start().` in the Erlang shell to watch your "
  <> "hello-world application consume system resources."
}
